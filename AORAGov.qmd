---
title: "AORA Review"
author: "Corey Scholes"
affiliation: "EBM Analytics"
version: 1.0
type: "website"
number-sections: true
number-depth: 3
date: "2025-Sep-03"
date-modified: "2025-Sep-03"

bibliography: AORAGov references.bib

editor:
  visual
format:
  html:
    toc: true
    number-sections: true
    code-fold: true
    link-external-newwindow: true
    link-external-icon: true
    
execute: 
  echo: false
  warning: false
  message: false
---

# Preamble

The following analysis is a report on the activity, quality and data contained in the AORA registry.

```{r}
#| label: load-packages

if (!require("pacman")) install.packages("pacman")
pacman::p_load(# Load required packages
  "mgcv",
  "ggforce",
  "ggdag",
  "ggmap",
  "ggsurvfit",
  "geosphere",
  "dplyr",
  "flextable",
  "litedown",
  "grateful",
  "modelsummary",
  "quantreg",
  "readr",
  "knitr",
  "cardx",
  "forcats",
  "gargle",
  "googledrive",
  "googlesheets4",
  "openxlsx2",
  "tidyverse",
  "tidymodels",
  "lubridate",
  "consort",
  "gtsummary",
  "survival",
  "ggplot2",
  "ggdist",
  "ggfortify",
  "mice",
  "marginaleffects",
  "naniar",
  "quantreg",
  "broom",
  "epoxy",
  "broom.helpers",
  "stringr"
  )
  
  
```

Access to the AORA datasets was pre-authorised.

```{r}
#| label: auth2
#| echo: false

options(
  gargle_oauth_cache = ".secrets",
  gargle_oauth_email = TRUE
)

googledrive::drive_auth(
  cache = ".secrets", 
  email = TRUE
  )
```

A function was generated to retrieve files to call on later in the analysis for processing data imports.

```{r}
#| label: folder
#| echo: false

base_folder_id1 <- "10ThtWn4-IIOuTYPbNrhJkL6yBuPQjk5S"



```

```{r}
get_specific_snapshot <- function(folder_name, base_folder_id = base_folder_id1) {
  tryCatch({
    # Check if the folder exists in the base directory
    folder <- googledrive::drive_ls(as_id(base_folder_id), pattern = paste0("^", folder_name, "$"))
    
    if(nrow(folder) == 0) {
      stop(paste("Folder", folder_name, "not found"))
    }
    
    # Find the snapshot file in the specified folder
    snapshot_file <- googledrive::drive_ls(
      folder$id, 
      pattern = "Registry data snapshot\\.xlsx$"
    )
    
    if(nrow(snapshot_file) == 0) {
      stop("No snapshot file found in specified folder")
    }
    
    # Return both pieces of information as a list
    return(list(
      snapshot = snapshot_file,
      folder_name = folder$name
    ))
    
  }, error = function(e) {
    stop(paste("Error finding specified snapshot:", e$message))
  })
}
```

Data was retrieved from live database tables. Source files were specified and stored as global variables to call on in further functions.

```{r}
#| label: live-table
#| echo: false

SheetIDs <- list(
DbSS = "https://docs.google.com/spreadsheets/d/1fhW1LJbsdvkA7u-z1IGgI2qHwiOWXP6RMRH8-cgPXU8/edit"
)

# Treatments Masterlist - Timestamp is > Registry Start date (gsuite)

```

```{r}
#| label: read-tables

# Authenticate for sheets using the same token
gs4_auth(token = drive_token())



ComplicTable <- googlesheets4::read_sheet(
  ss = SheetIDs$DbSS,
  sheet = "Complications", 
  col_names = TRUE, 
  col_types = "TccDccDc"
  )


#To match to acctData
PatientTable <- googlesheets4::range_read(
  ss = SheetIDs$DbSS,
  sheet = "Patient", 
  range = "A7:P",
  col_names = FALSE, 
  col_types = "DccccDcccDciccci"
  )


Patient_Col <- c(
  "PatientCreationDate",
  "PatientID",
  "LastName",	
  "FirstName",	
  "AlternateID",	
  "DateOfBirth",	
  "Sex",	
  "RegistryStatus",	
  "RegistryStatusNotes",	
  "DateRegistryStatus",	
  "NotificationMethod",	
  "NoTreatmentRecords",	
  "Email",	
  "Phone",
  "PostCode",
  "TrueNoTreatments"
)

colnames(PatientTable) <- Patient_Col


MonitorPlan <- googlesheets4::range_read(
  ss = SheetIDs$DbSS,
  sheet = "Monitor Module", 
  range = "A1:O",
  col_names = TRUE, 
  col_types = "ccccDTtincTccii"
  )


MonitorLog <- googlesheets4::range_read(
  ss = SheetIDs$DbSS,
  sheet = "MonitorModuleLog", 
  range = "A1:K",
  col_names = TRUE, 
  col_types = "Tcicccccccc"
  )

MonitorResponse <- googlesheets4::range_read(
  ss = SheetIDs$DbSS,
  sheet = "Monitoring", 
  range = "A1:Q",
  col_names = TRUE, 
  col_types = "TccccccccccnccDic"
  )


```

A static registry snapshot was retrieved and formatted based on the fixed date of preparation of the snapshot (31-Aug-2025).

```{r}

# Authenticate for sheets using the same token
gs4_auth(token = drive_token())

# To get a snapshot from a specific folder (e.g., "20230415")
specific_snapshot <- get_specific_snapshot("20250826")


```

```{r}

temp_file1 <- tempfile(fileext = ".xlsx")
drive_download(
  file = specific_snapshot$snapshot$id,
  path = temp_file1,
  overwrite = TRUE
)

# Correction to reset back to excel origin
DaysDiff <- as.numeric(as.duration(interval(ymd("1899-12-30"), ymd("1970-01-01"))),"days")


Snapshot <- openxlsx2::wb_to_df(
  temp_file1,
  sheet = "Combined",
  colNames = TRUE,
  detectDates = TRUE
  ) |> mutate(
    PatientID = stringr::str_split_i(TreatmentID,"\\.",1),
     SurgicalTreatment2 = case_when(
       stringr::str_detect(str_to_lower(EBMAComment),"surgery recommended") &
       stringr::str_detect(str_to_lower(SurgicalTreatment), "non") ~ "Surgery recommended",
       stringr::str_detect(str_to_lower(SurgicalTreatment), "non", negate = TRUE) ~ "Surgical",
       stringr::str_detect(str_to_lower(SurgicalTreatment), "non") ~ "Non-Surgical"
  )
  ) |> unite(
  col = "CombID",
  sep = ".",
  c("PatientID","AffectedSide"),
  remove = FALSE
)




STROBEInput <- openxlsx2::wb_to_df(
  temp_file1,
  sheet = "Strobe_Input",
  colNames = TRUE,
  detectDates = TRUE
  )

```

# Context

The Arthroplasty Outcomes in Regional Australia (AORA) registry has been in operation since June 2020, collecting KneeArthritis and HipArthritis presentations to a private clinic in Grafton, NSW. The setup of the registry is detailed on the [registry wiki](https://sites.google.com/ebma.com.au/aora-registry-wiki/home). The registry started with two surgeons contributing with one surgeon stopping participation in December 2022.

The registry has HREC approval until **21-Oct-2025** and the HREC has recommended that;

::: {#hrecquote}
> ...this provides the opportunity for the research team to review the HREC approved protocol and related study material given the amount of time elapsed since first approved in October, 2020. Before the next progress report is due (21/10/2025) please submit a ethics amendment with tracked changes and a request for an extension to HREC approval (if required).
:::

# Recruitment Flow by Region

Flowcharts as per STROBE [@Vandenbroucke2007] and RECORD [@Benchimol2015] guidelines were generated for treatments enrolled into the Registry. Followup was set to eligibility at 12months followup.

```{r}


STROBEFlow2 <- STROBEInput |> 
  # Filter out rows with missing TreatmentID
  dplyr::filter(
    !is.na(TreatmentID),
    str_detect(RegistryCohortName,"Non", negate = TRUE)
                ) |> dplyr::left_join(# Join with relevant columns from Snapshot
    Snapshot |> 
      dplyr::select(
        TreatmentID,
        CombID,
        EligibleAtPreop,
        EligibleAtx12months,
        SurgicalTreatment2
      ) |> 
      # Convert all date columns to date format
      dplyr::mutate(
        across(contains("Date"), lubridate::ymd)
      ),
    # Explicitly specify join column
    by = "TreatmentID"
  ) |> dplyr::mutate(
    TreatmentStatus2 = if_else(
          TreatmentStatus == "No further followup" & is.na(DateTreatment),
          "Archived",
          TreatmentStatus
  )
  )

```

```{r}

CurrentDate <- as.character("20250617")

STROBEFlow3 <- STROBEFlow2 |> dplyr::mutate(
    exclusion1 = case_when(
    is.na(SurgicalTreatment) ~ "Not a surgical treatment",
    SurgicalTreatment == "Surgical" & stringr::str_detect(RegistryStatus,"Opt-out") ~ "Patient Opt-Out",
    SurgicalTreatment == "Surgical" & is.na(RegistryCohortName) ~ "No cohort",
    SurgicalTreatment == "Surgical" ~ NA_character_,
    .default = "Not a surgical treatment"
  ),
  followup = if_else(
    is.na(exclusion1),
    TreatmentID,
    NA_character_
  ),
  lost_followup = case_when(
    is.na(exclusion1) & TreatmentStatus2 == "Failed" & (ymd(DateStatusChange) < ymd(CurrentDate)) ~ "Procedure failure",
    is.na(exclusion1) & TreatmentStatus2 == "No further followup" & (ymd(DateStatusChange) < ymd(CurrentDate)) ~ "Patient Opt-out",
    is.na(exclusion1) & is.na(EligibleAtx12months) ~ "Not eligible for followup"
  ),
  mitt = if_else(
    !is.na(followup) & is.na(lost_followup),
    TreatmentID,
    NA_character_
)
) |> dplyr::rename(
  trialno = "TreatmentID",
  arm3 = "RegistryCohortName"
)

```

```{r}

STROBEReview <- STROBEFlow3 |> dplyr::filter(
  !(TreatmentStatus == "Archived")
) |> group_by(arm3) |> summarise(CohortCount = n()) |> arrange(desc(CohortCount))

```

```{r}
#| label: fig-strobe-cohort1
#| fig-cap: "Flowchart of extraction and followup of surgical sample from the Registry - 1"


STROBEPlot1 <- consort_plot(
  data = STROBEFlow3,
 orders = c(
   trialno = "Population",
   exclusion1 = "Ineligible",
   trialno = "Baseline Analysis",
   arm3 = "Cohort",
   lost_followup = "Excluded",
   mitt = "Followup Analysis"
   ),
 side_box = c(
   "exclusion1",
   "lost_followup"
   ),
 allocation = "arm3",
 cex = 0.6
)

knitr::knit_print(STROBEPlot1)

```

Cumulative recruitment over time was plotted from Registry inception to the present.

```{r}
#| label: fig-progress
#| fig-cap: "Cumulative record creation within AORA from inception to present"


RecordCount <- dplyr::summarise(
  STROBEFlow3 |>  dplyr::filter(
    !(TreatmentStatus == "Archived")
    ),
  Count = n(),
  .by = PatientCreationDate
) |> arrange(
  PatientCreationDate
) |> dplyr::mutate(
  CumulativeCount = cumsum(Count),
  PatientCreationNum = as.numeric(PatientCreationDate)
  ) |> filter(
    !(PatientCreationDate < ymd("20160701"))
   
  )

cumulative_plot <- ggplot(RecordCount, aes(x = PatientCreationDate, y = CumulativeCount)) +
  geom_line(color = "#2c3e50", linewidth = 1) +
  # Add the spline fit with confidence interval
  geom_smooth(method = "gam", formula = y ~ s(x, bs = "cs"), 
              color = "#e74c3c", linewidth = 1.2, se = TRUE, fill = "#e74c3c", alpha = 0.2) +
  geom_point(color = "#3498db", size = 1) +
  # Add labels and title
  labs(
    x = "Date",
    y = "Cumulative Number of Patients",
    #caption = "Data source: STROBEFlow3"
  ) +
  # Improve the theme and formatting
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title = element_text(face = "bold"),
    panel.grid.minor = element_blank()
  )

# Print the plot
knitr::knit_print(cumulative_plot)


```

The trend in @fig-progress shows a reduction in recruitment rates to the registry as inclusion criteria have been refined and improved specificity in bringing cases into the registry has been achieved.

# Missingness and Engagement

Calculations have been made regarding the capture rate for PROMs at set timepoints and for intraoperative data with regard to surgical cases.

## Baseline and Intraoperative

Patients are enrolled to a registry cohort and sent relevant questionnaires for their presentation around their initial consultation, or prior to surgery to establish a baseline. The referral pathways for surgery have been fluid over time and the participation of other surgeons to intraoperative data collection has been absent, therefore the missingness was calculated only for surgical cases treated by the participating surgeon.

```{r}
#| label: fig-baseline-miss
#| fig-cap: "Missingness of baseline PROMs and intraoperative date by registry cohort"

gg_miss_fct(Snapshot |> dplyr::filter(
      EligibleAtPreop == "Yes" | EligibleAtIntraop == "Yes",
      SurgicalTreatment == "Surgical",
      Surgeon == "SM"
      ) |> dplyr::select(
        VR12_Physical_TotalScore_Preop,
        Anaesthetic,
        #TreatmentProvider, 
        RegistryCohortName
        ), 
      RegistryCohortName
      )


```

Missingness for baseline PROMs (represented by VR12) and intraoperative data is captured in @fig-baseline-miss. Overall, the patient response rate at baseline is \~65%. Intraoperative data missingness may be have multiple causal pathways - some may have been missed by the operating surgeon, or that there is a proportion of non-arthroplasty surgical cases included in the cohort dataset.

## Patient-reported Outcomes by TimePoint

Patients are sent sms around their surgical anniversay at the times illustrated in the figures below.

```{r}
min_percent <- 10
max_percent <- 100  # Or another value that encompasses all your data
```

```{r}
#| label: fig-ka-miss
#| fig-cap: "Missingness of KOOS12 by Timepoint in Knee Arthritis surgical cases"

SnapshotKA <- Snapshot |> dplyr::filter(
  RegistryCohortName == "KneeArthritis"
  ) |> rename_with(
  ~gsub("Atx","At_",.x, fixed = TRUE)
) |> rename_with(
  ~gsub("KOOS12_Summary_TotalScore","KOOS12TotalScore",.x, fixed = TRUE
        ) 
  ) |> rename(
  EligibleAt_Preop = "EligibleAtPreop"
) |> dplyr::mutate(
  Status = if_else(
    TreatmentStatus == "Failed",
    1,
    0
  ),
  EndDate = case_when(
    !is.na(DateStatusChange) ~ DateStatusChange,
    .default = coalesce(DateStatusChange, ymd(CurrentDate)),
    ),
  Duration = as.numeric(as.duration(interval(ymd(DateTreatment), ymd(EndDate))),"weeks")
)

PROMKA <- SnapshotKA |> dplyr::select(
  TreatmentID,
  starts_with("KOOS12TotalScore"),
  starts_with("EligibleAt"),
  -EligibleAtIntraop
) |> pivot_longer(
  cols = !TreatmentID,
  names_to = c(".value","TimePoint"),
  names_sep = "_",
  values_drop_na = TRUE
) |> mutate(
  TimePoint = factor(TimePoint, levels = c("Preop","6weeks", "3months","6months","12months","24months"), ordered = TRUE, exclude = NA),
) |> dplyr::filter(
  EligibleAt == "Yes",
  !is.na(TimePoint)
) |> left_join(
  SnapshotKA |> dplyr::select(
    TreatmentID,
    SurgicalTreatment2
  ),
  by = "TreatmentID"
)
# 
# 
# 
gg_miss_fct(PROMKA |> dplyr::filter(SurgicalTreatment2 == "Surgical") |> dplyr::select(KOOS12TotalScore,TimePoint), TimePoint) + scale_fill_viridis_c(
    option = "plasma",  # or "inferno", "magma", "cividis"
    name = "% Missing",
    limits = c(30, 80)  # Set limits from 0% to 100%
  )
```

```{r}
#| label: fig-ha-miss
#| fig-cap: "Missingness of HOOS12 by Timepoint in Hip Arthritis cohort surgical cases"

SnapshotHA <- Snapshot |> dplyr::filter(
  RegistryCohortName == "HipArthritis"
  ) |> rename_with(
  ~gsub("Atx","At_",.x, fixed = TRUE)
) |> rename_with(
  ~gsub("HOOS12_Summary_TotalScore","HOOS12TotalScore",.x, fixed = TRUE
        ) 
  ) |> rename(
  EligibleAt_Preop = "EligibleAtPreop"
) |> dplyr::mutate(
  Status = if_else(
    TreatmentStatus == "Failed",
    1,
    0
  ),
  EndDate = case_when(
    !is.na(DateStatusChange) ~ DateStatusChange,
    .default = coalesce(DateStatusChange, ymd(CurrentDate)),
    ),
  Duration = as.numeric(as.duration(interval(ymd(DateTreatment), ymd(EndDate))),"weeks")
)

PROMHA <- SnapshotHA |> dplyr::select(
  TreatmentID,
  starts_with("HOOS12TotalScore"),
  starts_with("EligibleAt"),
  -EligibleAtIntraop
) |> pivot_longer(
  cols = !TreatmentID,
  names_to = c(".value","TimePoint"),
  names_sep = "_",
  values_drop_na = TRUE
) |> mutate(
  TimePoint = factor(TimePoint, levels = c("Preop", "3months","6months","12months","24months"), ordered = TRUE, exclude = NA),
) |> dplyr::filter(
  EligibleAt == "Yes",
  !is.na(TimePoint)
) |> left_join(
  SnapshotHA |> dplyr::select(
    TreatmentID,
    SurgicalTreatment2
  ),
  by = "TreatmentID"
)
# 
# 
# 
gg_miss_fct(PROMHA |> dplyr::filter(SurgicalTreatment2 == "Surgical") |> dplyr::select(HOOS12TotalScore,TimePoint), TimePoint) + scale_fill_viridis_c(
    option = "plasma",  # or "inferno", "magma", "cividis"
    name = "% Missing",
    limits = c(30, 80)  # Set limits from 0% to 100%
  )
```

The cumulative results in @fig-ka-miss and @fig-ha-miss illustrate the difficulty in engaging patients beyond short term followup.

## Baseline by Year

Patient responses to baseline scores were assessed over time. The VR12 is a *general* health questionnaire that is presented to *all* patients enrolled in the registry, regardless of cohort.

```{r}
#| label: fig-vr12-missbaseka
#| fig-cap: "Missingness of Baseline VR12 by Month in the Knee Arthritis cohort"


PROMVR12 <- SnapshotKA |> dplyr::select(
  TreatmentID,
  VR12_Physical_TotalScore_Preop,
  SurgicalTreatment2
) |> left_join(
  STROBEFlow3 |> dplyr::select(
    trialno,
    DateTreatmentRecordCreation
  ) |> dplyr::mutate(
    CreationYear = lubridate::year(DateTreatmentRecordCreation),
    CreationMonth = lubridate::month(DateTreatmentRecordCreation)
    ),
  join_by(TreatmentID == trialno)
) |> dplyr::select(
  CreationYear,
  VR12_Physical_TotalScore_Preop,
  SurgicalTreatment2
)

gg_miss_fct(PROMVR12 |> dplyr::filter(SurgicalTreatment2 == "Surgical") |> dplyr::select(VR12_Physical_TotalScore_Preop, CreationYear), CreationYear) + scale_fill_viridis_c(
    option = "plasma",  # or "inferno", "magma", "cividis"
    name = "% Missing",
    limits = c(30, 80)  # Set limits from 0% to 100%
  )

```

```{r}
#| label: fig-vr12-missbaseha
#| fig-cap: "Missingness of Baseline VR12 by year in the Hip Arthritis cohort"


PROMVR12 <- SnapshotHA |> dplyr::select(
  TreatmentID,
  VR12_Physical_TotalScore_Preop,
  SurgicalTreatment2
) |> left_join(
  STROBEFlow3 |> dplyr::select(
    trialno,
    DateTreatmentRecordCreation
  ) |> dplyr::mutate(
    CreationYear = lubridate::year(DateTreatmentRecordCreation),
    CreationMonth = lubridate::month(DateTreatmentRecordCreation)
    ),
  join_by(TreatmentID == trialno)
) |> dplyr::select(
  CreationYear,
  VR12_Physical_TotalScore_Preop,
  SurgicalTreatment2
)

gg_miss_fct(PROMVR12 |> dplyr::filter(SurgicalTreatment2 == "Surgical") |> dplyr::select(VR12_Physical_TotalScore_Preop, CreationYear), CreationYear) + scale_fill_viridis_c(
    option = "plasma",  # or "inferno", "magma", "cividis"
    name = "% Missing",
    limits = c(20, 70)  # Set limits from 0% to 100%
  )
```

The missingness rates for @fig-vr12-missbaseka and @fig-vr12-missbaseha show improving engagement rates over the last two years of operation

# Cohort Analysis

The VR12 component scores were compared between cohorts at baseline.

```{r}
#| label: fig-vr12pcs-cohort
#| fig-cap: "Summary of VR12 at baseline by cohort"

Snapshot <- dplyr::mutate(
  Snapshot,
  across(contains("Score"), ~as.numeric(.))
)

FigureVR12PCS <- Snapshot |> ggplot(aes(y = RegistryCohortName, x = VR12_Physical_TotalScore_Preop)) +
  stat_halfeye(fill = "steelblue")


knitr::knit_print(FigureVR12PCS)

```

```{r}
#| label: fig-vr12mcs-cohort
#| fig-cap: "Summary of VR12 Mental Component at baseline by cohort"

Snapshot <- dplyr::mutate(
  Snapshot,
  across(contains("Score"), ~as.numeric(.))
)

FigureVR12MCS <- Snapshot |> ggplot(aes(y = RegistryCohortName, x = VR12_Mental_TotalScore_Preop)) +
  stat_halfeye(fill = "steelblue")


knitr::knit_print(FigureVR12MCS)

```

Between-cohort variability is observed for the Physical Component Score of the VR12 (@fig-vr12pcs-cohort), but not as pronounced for the Mental Component Score (@fig-vr12mcs-cohort). Most notable is the high variation within all cohorts for both component scores.

```{r}


PROMMODEM <-  Snapshot |> rename_with(
  ~gsub("Atx","At_",.x, fixed = TRUE)
) |> rename(
  EligibleAt_Preop = "EligibleAtPreop"
) |> dplyr::select(
  starts_with("MODEMP"),
  starts_with("Eligible"),
  TreatmentID
)

PROMMODEM1 <- PROMMODEM |> dplyr::select(
  -EligibleAtIntraop
) |> pivot_longer(
  cols = !TreatmentID,
  names_to = c(".value","TimePoint"),
  names_sep = "_",
  values_drop_na = TRUE
) |> mutate(
  TimePoint = factor(TimePoint, levels = c("6months","12months","24months"), ordered = TRUE, exclude = NA),
  across(starts_with("MODEMP"), ~ forcats::fct(
    .,
    levels = c(
    "Not applicable",
    "Definitely not",
    "Probably not",
    "Not sure",
    "Probably yes",
    "Definitely yes"
  ))
)
) |> dplyr::filter(
  EligibleAt == "Yes",
  !is.na(TimePoint)
) |> left_join(
  Snapshot |> dplyr::select(
    TreatmentID,
    SurgicalTreatment,
    RegistryCohortName
  ),
  by = "TreatmentID"
)

```

```{r}
#| label: fig-modempre1
#| fig-cap: "Expectations of symptom relief in surgical cases by Cohort captured by pre-treatment MODEMs"

Snapshot1 <- Snapshot |> dplyr::mutate(
  MODEMQ1_Preop = forcats::fct(
    MODEMQ1_Preop,
    levels = c(
    "Not applicable",
    "Not at all likely",
    "Slightly likely",
    "Somewhat likely",
    "Very likely",
    "Extremely likely"
  ))
)

FigModem1Pre <- ggplot(Snapshot1 |> dplyr::filter(
  !is.na(MODEMQ1_Preop),
  SurgicalTreatment == "Surgical"
  ),
  aes(x = RegistryCohortName,
      fill = MODEMQ1_Preop)
  ) +
  geom_bar(position = "fill") +
  scale_fill_viridis_d(option = "viridis") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "right"
  )


knitr::knit_print(FigModem1Pre)
```

```{r}
#| label: fig-modemp1
#| fig-cap: "Satisfaction with symptom relief in surgical cases by Cohort captured by post-operative MODEMs"

FigModemP1 <- ggplot(PROMMODEM1 |> dplyr::filter(!is.na(MODEMPQ1), SurgicalTreatment == "Surgical"), aes(x = TimePoint, fill = MODEMPQ1)) +
  geom_bar(position = "fill") +
  facet_wrap(~ RegistryCohortName) +
  labs(#title = "",
       x = "Cohort",
       y = "Count",
       fill = "Outcome") +
  scale_fill_viridis_d(option = "viridis") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    legend.position = "right"
  )



knitr::knit_print(FigModemP1)
```

```{r}
#| label: fig-modemp3
#| fig-cap: "Satisfaction with sleep comfort by Cohort captured by post-operative MODEMs"

FigModemP3 <- ggplot(PROMMODEM1 |> dplyr::filter(!is.na(MODEMPQ3), SurgicalTreatment == "Surgical"), aes(
  x = TimePoint, fill = MODEMPQ3)) +
  geom_bar(position = "fill") +
  facet_wrap(~ RegistryCohortName) +
  labs(#title = "Satisfaction with sleep comfort by Time Point and Cohort",
       x = "Cohort",
       y = "Count",
       fill = "Outcome") +
  scale_fill_viridis_d(option = "viridis") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "right"
  )

knitr::knit_print(FigModemP3)
```

## Complications

```{r}


SnapshotSurg <- Snapshot |> dplyr::filter(
  SurgicalTreatment2 == "Surgical",
  Surgeon == "SM"
) |> dplyr::select(
  TreatmentID,
  RegistryCohortName,
  DateTreatment,
  TreatmentStatus,
  TreatmentStatusNotes,
  DateStatusChange,
  ComplicationOccurrence,
  DateOfOccurrence,
  ComplicationNature,
  ReoperationProcedure,
  ReoperationProcedureDate
) |> mutate(
  ComplicationOccur2 = if_else(
    is.na(ComplicationOccurrence),
    "No",
    ComplicationOccurrence
  ),
  OccurDelay =  as.numeric(as.duration(interval(ymd(DateTreatment), ymd(DateOfOccurrence))),"days"),
  Followup = if_else(
    is.na(DateStatusChange),
    as.numeric(as.duration(interval(ymd(DateTreatment), ymd(CurrentDate))),"days"),
    as.numeric(as.duration(interval(ymd(DateTreatment), ymd(DateStatusChange))),"days")
  )
)


```

```{r}
#| label: tbl-comp
#| tbl-cap: "Summary of complications incidence after surgery separated by cohort"

TableComp <- gtsummary::tbl_summary(
  SnapshotSurg |> dplyr::select(
    RegistryCohortName,
    ComplicationOccur2,
    OccurDelay,
    Followup
  ),
  by = "RegistryCohortName",
  missing = "no"
) |>
  modify_footnote_body(
    footnote = "Days",
    columns = "label",
    rows = variable == c("OccurDelay","Followup") & row_type == "label"
  ) |> add_overall()

knitr::knit_print(TableComp)


```

Adverse events were detected in 16% of surgical cases performed by SM over the life of the registry as shown in @tbl-comp, with an average detection with 14 days of surgery and 50% of cases detected within 60 days, with some instances for the Knee Arthritis occurring later than Hip Arthritis.

## Knee Arthritis

The demographics for surgical cases in the Knee Arthritis cohort are presented below.

```{r}
#| label: tbl-ka-demographics
#| tbl-cap: "Summary of demographics in Knee Arthritis cohort"

TableKAdemo <- gtsummary::tbl_summary(
  Snapshot |> dplyr::filter(
    str_detect(RegistryCohortName,"KneeArthritis")
  ) |> dplyr::select(
    TreatmentType,
    SurgicalTreatment2,
    TreatmentStatus,
    DateInitialExamination,
    AgeAtInitialExam,
    Sex
  ),
  by = "SurgicalTreatment2",
  missing = "no",
  statistic = list(
    DateInitialExamination ~ "{min} - {max}"
  )
)

knitr::knit_print(TableKAdemo)
```

Each cohort is broken down into non-surgical cases, cases that have been offered surgery but have yet to take up the offer and surgical cases (@tbl-ka-demographics).

```{r}

# Extract volume
extract_primary_dose <- function(text) {
  as.numeric(str_extract(text, "\\d+\\.?\\d*(?=\\s*ml)"))
}

# Extract primary anaesthetic agent
extract_primary_agent <- function(text) {
  text_clean <- str_to_lower(str_trim(text))
  case_when(
    str_detect(text_clean, "marcain|bupivacaine") ~ "marcain",
    str_detect(text_clean, "lidocaine|lignocaine") ~ "lidocaine",
    TRUE ~ str_to_lower(str_extract(text_clean, "(?<=ml\\s)\\w+"))
  )
}

# Extract secondary drug dose
extract_secondary_dose <- function(text) {
  as.numeric(str_extract(text, "\\d+(?=\\s*mcg)"))
}

# Extract secondary drug name
extract_secondary_agent <- function(text) {
  text_clean <- str_to_lower(str_trim(text))
  case_when(
    str_detect(text_clean, "morphine") ~ "morphine",
    str_detect(text_clean, "fentanyl|fent") ~ "fentanyl",
    str_detect(text_clean, "tramadol") ~ "tramadol",
    TRUE ~ str_to_lower(str_extract(text_clean, "(?<=mcg\\s)\\w+"))
  )
}

```

```{r}
#Clean up intraop variables
#
SnapshotKA2 <- SnapshotKA |> dplyr::filter(
    Surgeon == "SM",
    str_detect(RegistryCohortName,"KneeArthritis"),
    SurgicalTreatment == "Surgical"
  ) |> dplyr::select(
    Anaesthetic,
    SpinalAnaestheticComposition
    ) |> dplyr::mutate(
      SpinalAnaestheticComposition2 = case_when(
        stringr::str_detect(str_to_lower(SpinalAnaestheticComposition),"marcian") ~ stringr::str_replace(str_to_lower(SpinalAnaestheticComposition),"marcian", "marcain"),
        stringr::str_detect(str_to_lower(SpinalAnaestheticComposition),"heavy|spinal") ~ stringr::str_remove(str_to_lower(SpinalAnaestheticComposition), "heavy|spinal"),
        .default = SpinalAnaestheticComposition
      ),
      SpinalAnaesth = if_else(
    stringr::str_detect(str_to_lower(Anaesthetic),"spinal"),
    "Yes",
    "No"
  ),
   Spinalprimary_dose = extract_primary_dose(SpinalAnaestheticComposition2),
    Spinalprimary_agent = extract_primary_agent(SpinalAnaestheticComposition2),
    Spinalsecondary_dose = extract_secondary_dose(SpinalAnaestheticComposition2),
    Spinalsecondary_agent = extract_secondary_agent(SpinalAnaestheticComposition2)
    )

```

```{r}
#| label: ka-intraop-clean


SnapshotKA2b <- SnapshotKA |> dplyr::mutate(
TibiaBrand2 = case_when(
  stringr::str_detect(str_to_lower(TibiaBrand),"gmk") ~ "Medacta GMK Sphere",
  stringr::str_detect(str_to_lower(TibiaBrand),"triathlon") ~ "Stryker Triathlon",
  stringr::str_detect(str_to_lower(TibiaBrand),"persona") ~ "Zimmer Persona",
  .default = TibiaBrand
),
BearingType2 = case_when(
  stringr::str_detect(str_to_lower(BearingType),"retain") ~ "Cruciate retaining",
  stringr::str_detect(str_to_lower(BearingType),"pivot") ~ "Medial pivot",
  stringr::str_detect(str_to_lower(BearingType),"cs") ~ "Condylar-stabilised",
  stringr::str_detect(str_to_lower(BearingType),"ps|posterior") ~ "Condylar-stabilised",
  stringr::str_detect(str_to_lower(BearingType),"ps|posterior") ~ "Mobile",
)
)
```

The intraoperative variables captured for surgeries in the Knee Arthritis cohort are summarised below.

```{r}
#| label: tbl-ka-intraop
#| tbl-cap: "Summary of intraoperative variables in Knee Arthritis cohort"



TableKAsurg1 <- gtsummary::tbl_summary(
  SnapshotKA2b |> dplyr::filter(
    SurgicalTreatment == "Surgical",
    Surgeon == "SM"
  ) |> dplyr::select(
    TourniquetApplied,
    ComponentStrategy,
    TibiaBrand2,
    TibiaFixation,
    BearingType2,
    PatellarResurfacing
    
    
  ) ,
  missing = "no"
)

knitr::knit_print(TableKAsurg1)


```

In addition, variables extracted from the free-text description of pain relief used during Knee Arthritis surgeries are summarised below.

```{r}
#| label: tbl-ka-painrelief
#| tbl-cap: "Summary of intraoperative variables in Knee Arthritis cohort"



TableKAsurg <- gtsummary::tbl_summary(
  SnapshotKA2 |> dplyr::select(
    SpinalAnaesth,
    Spinalprimary_agent,
    Spinalprimary_dose,
    Spinalsecondary_agent,
    Spinalsecondary_dose
    
  ),
  missing = "ifany"
)

knitr::knit_print(TableKAsurg)


```

The KOOS12 is captured for all cases within the Knee Arthritis cohort, with the distributions at each timepoint shown below.

```{r}
#| label: fig-koos-ka
#| fig-cap: "Summary of KOOS12 by Timepoint"

preop_position <- which(levels(PROMKA$TimePoint) == "Preop")


PROMKA2 <- dplyr::mutate(
  PROMKA,
  across(contains("TotalScore"), ~as.numeric(.))
)
FigureKOOS_overlay <- PROMKA2 |> dplyr::filter(
  !(is.na(SurgicalTreatment2))
) |> ggplot(aes(y = KOOS12TotalScore, x = TimePoint, fill = SurgicalTreatment2, color = SurgicalTreatment2)) +
  stat_halfeye(
    alpha = 0.5,  # Transparency for overlap visibility
    position = "identity",  # Overlay the distributions
    na.rm = TRUE,
    scale = 0.9  # Slightly scale down to avoid too much overlap
  ) +
  # Add the ellipse annotation
  ggforce::geom_ellipse(aes(x0 = preop_position, 
                  y0 = 70, 
                  a = 0.3, 
                  b = 5, 
                  angle = 0),
             color = "red", 
             size = 1.2,
             inherit.aes = FALSE) +
  annotate("text", 
           x = preop_position + 0.4, 
           y = 85,
           label = "High preop scores",
           color = "red",
           fontface = "bold",
           size = 3.5) +
  # Add appropriate scale colors
  scale_fill_manual(values = c("Surgical" = "steelblue", "Non-Surgical" = "darkgray", "Surgery recommended" = "darkred")) +
  scale_color_manual(values = c("Surgical" = "steelblue4", "Non-Surgical" = "dimgray", "Surgery recommended" = "darkred")) +
  labs(
    y = "KOOS12 Total Score",
    x = "Time Point",
    fill = "Treatment",
    color = "Treatment"
  ) +
  theme_minimal() +
  theme(
    legend.position = "top",
    panel.grid.minor = element_blank()
  )

knitr::knit_print(FigureKOOS_overlay)
```

The KOOS12 summary score illustrated in @fig-koos-ka demonstrates potential ceiling efffects in surgical cases at later timepoints, but importantly identifies stark differences between patient subgroups with similar diagnoses over time.

```{r}
#| label: fig-kneeling
#| fig-cap: "Distribution of kneeling difficulty responses at 6 weeks after surgery"

SnapshotKA1 <- SnapshotKA |> dplyr::mutate(
  Kneeling_6weeks = forcats::fct(
    Kneeling_6weeks,
    levels = c(
    "Extreme",
    "Severe",
    "Moderate",
    "Mild",
    "None"
  ))
)

FigModem1Pre <- ggplot(
  SnapshotKA1 |> 
    dplyr::filter(
      !is.na(Kneeling_6weeks),
      SurgicalTreatment == "Surgical"
    ),
  aes(x = Kneeling_6weeks, fill = Kneeling_6weeks)
) +
  geom_bar(color = "white", size = 0.2) +
  geom_text(
    stat = "count",
    aes(label = paste0(round(after_stat(count)/sum(after_stat(count))*100, 1), "%")),
    vjust = -0.5,
    color = "black",
    size = 4,
    fontface = "bold"
  ) +
  scale_fill_viridis_d(
    option = "viridis",
    name = "Kneeling Difficulty\n(6 weeks)"
  ) +
  scale_y_continuous(
    name = "Number of Responses"
  ) +
  labs(
    x = "Kneeling Difficulty Level"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "none",  # Remove legend since x-axis shows categories
    panel.grid.major.x = element_blank(),
    panel.grid.minor = element_blank()
  )


knitr::knit_print(FigModem1Pre)
```

The cohort results to date demonstrate that more than 50% of cases undergoing surgery for Knee Arthritis in the registry report moderate to no difficulties in kneeling at the 6 week followup (@fig-kneeling).

```{r}
#| label: fig-surv-ka
#| fig-cap: "Survival curve for Knee Arthritis cases by treatment type"


FigureSurvKA <- survfit2(Surv(Duration, Status) ~ SurgicalTreatment2,
                        data = SnapshotKA
                        ) |> ggsurvfit(linewidth = 1) +
  add_confidence_interval() +
  add_risktable() +
  add_quantile(y_value = 0.6, color = "gray50", linewidth = 0.75) +
  scale_ggsurvfit() +
  coord_cartesian(ylim = c(0.7, 1))

knitr::knit_print(FigureSurvKA)

```

```{r}
#| label: tbl-surv-ka
#| tbl-cap: "Summary of Knee Arthritis Procedure Survival"

TableSurvKA <- tbl_survfit(
  survfit2(Surv(Duration, Status) ~ SurgicalTreatment2, 
           data = SnapshotKA),
  times = c(1,26,52,104),
  label_header = "**{time} Weeks**",
  label = "Procedure Survival",
  statistic = "{estimate} ({conf.low} - {conf.high})"
)

knitr::knit_print(TableSurvKA)

```

The procedure survival of treatments captured in the registry are different depending on the treatment classification @fig-surv-ka . Importantly, it is likely that the rate of surgical failures\|revisions is under-reported in this registry, as the ability to detect subsequent revisions for patients that go to other surgeons is limited to those that practice at SOC in Grafton. A key finding of the survival curves is that the rate of conversion to surgery for patients that have or have not been recommended surgery as a treatment option have similar rates (failure) of conversion to surgery over a \~3 year period after the initial consulation.

## Hip Arthritis

The hip arthritis cohort captures all patients presenting with degenerative conditions of the femoracetabular joint to be assessed for suitability for arthroplasty or other surgery. The demographics of the cohort are summarised below.

```{r}
#| label: tbl-ha-demographics
#| tbl-cap: "Summary of demographics in Hip Arthritis cohort"

TableHAdemo <- gtsummary::tbl_summary(
  Snapshot |> dplyr::filter(
    str_detect(RegistryCohortName, "HipArthritis")
  ) |> dplyr::select(
    TreatmentType,
    SurgicalTreatment2,
    TreatmentStatus,
    DateInitialExamination,
    AgeAtInitialExam,
    Sex
  ),
  by = "SurgicalTreatment2",
  missing = "no",
  statistic = list(
    DateInitialExamination ~ "{min} - {max}"
  )
)

knitr::knit_print(TableHAdemo)
```

```{r}
#Clean up intraop variables
#
SnapshotHA2 <- SnapshotHA |> dplyr::filter(
    Surgeon == "SM",
    str_detect(RegistryCohortName,"HipArthritis"),
    SurgicalTreatment == "Surgical"
  ) |> dplyr::select(
    Anaesthetic,
    SpinalAnaestheticComposition
    ) |> dplyr::mutate(
      SpinalAnaestheticComposition2 = case_when(
        stringr::str_detect(str_to_lower(SpinalAnaestheticComposition),"marcian") ~ stringr::str_replace(str_to_lower(SpinalAnaestheticComposition),"marcian", "marcain"),
        stringr::str_detect(str_to_lower(SpinalAnaestheticComposition),"heavy|spinal") ~ stringr::str_remove(str_to_lower(SpinalAnaestheticComposition), "heavy|spinal"),
        .default = SpinalAnaestheticComposition
      ),
      SpinalAnaesth = if_else(
    stringr::str_detect(str_to_lower(Anaesthetic),"spinal"),
    "Yes",
    "No"
  ),
   Spinalprimary_dose = extract_primary_dose(SpinalAnaestheticComposition2),
    Spinalprimary_agent = extract_primary_agent(SpinalAnaestheticComposition2),
    Spinalsecondary_dose = extract_secondary_dose(SpinalAnaestheticComposition2),
    Spinalsecondary_agent = extract_secondary_agent(SpinalAnaestheticComposition2)
    )

```

```{r}
#| label: ha-intraop-clean


SnapshotHA2b <- SnapshotHA |> dplyr::mutate(
FemurBrand2 = case_when(
  stringr::str_detect(str_to_lower(FemurBrand),"medacta|masterloc") ~ "Medacta",
  stringr::str_detect(str_to_lower(FemurBrand),"stryker") ~ "Stryker",
  .default = FemurBrand
),
CupBrand2 = case_when(
  stringr::str_detect(str_to_lower(CupBrand),"medacta|mpact") ~ "Medacta",
  stringr::str_detect(str_to_lower(CupBrand),"stryker|trident") ~ "Stryker",
  .default = CupBrand
)
)
```

The intraoperative fields captured for hip arthritis surgery is captured below.

```{r}
#| label: tbl-ha-intraop
#| tbl-cap: "Summary of intraoperative variables in Hip Arthritis cohort"

TableHAsurg <- gtsummary::tbl_summary(
  SnapshotHA2b |> dplyr::filter(
    SurgicalTreatment == "Surgical",
    Surgeon == "SM"
  ) |> dplyr::select(
    Approach:ComponentAlignment,
    FemurBrand2,
    FemurFixation,
    CupBrand2,
    CupFixation
    
  ),
  missing = "no"
)

knitr::knit_print(TableHAsurg)


```

```{r}
#| label: tbl-ha-painrelief
#| tbl-cap: "Summary of intraoperative variables in Hip Arthritis cohort"



TableHAsurg <- gtsummary::tbl_summary(
  SnapshotHA2 |> dplyr::select(
    SpinalAnaesth,
    Spinalprimary_agent,
    Spinalprimary_dose,
    Spinalsecondary_agent,
    Spinalsecondary_dose
    
  ),
  missing = "no"
)

knitr::knit_print(TableHAsurg)


```

```{r}
#| label: fig-hoos-ha
#| fig-cap: "Summary of HOOS12 by Timepoint"



PROMHA2 <- dplyr::mutate(
  PROMHA,
  across(contains("TotalScore"), ~as.numeric(.))
)

FigureHOOS_overlay <- PROMHA2 |> dplyr::filter(
  !(is.na(SurgicalTreatment2))
) |> ggplot(aes(y = HOOS12TotalScore, x = TimePoint, fill = SurgicalTreatment2, color = SurgicalTreatment2)) +
  stat_halfeye(
    alpha = 0.5,  # Transparency for overlap visibility
    position = "identity",  # Overlay the distributions
    na.rm = TRUE,
    scale = 0.9  # Slightly scale down to avoid too much overlap
  ) +
  # Add appropriate scale colors
  scale_fill_manual(values = c("Surgical" = "steelblue", "Non-Surgical" = "darkgray", "Surgery recommended" = "darkred")) +
  scale_color_manual(values = c("Surgical" = "steelblue4", "Non-Surgical" = "dimgray", "Surgery recommended" = "darkred")) +
  labs(
    y = "HOOS12 Total Score",
    x = "Time Point",
    fill = "Treatment",
    color = "Treatment"
  ) +
  theme_minimal() +
  theme(
    legend.position = "top",
    panel.grid.minor = element_blank()
  )

knitr::knit_print(FigureHOOS_overlay)
```

The trajectory of HOOS12 summary score shows stark differences in distributions over time, with a similar ceiling effect for surgical cases at longer followup.

```{r}
#| label: fig-surv-ha
#| fig-cap: "Survival curve for Hip Arthritis cases by treatment type"


FigureSurvHA <- survfit2(Surv(Duration, Status) ~ SurgicalTreatment2,
                        data = SnapshotHA
                        ) |> ggsurvfit(linewidth = 1) +
  add_confidence_interval() +
  add_risktable() +
  add_quantile(y_value = 0.6, color = "gray50", linewidth = 0.75) +
  scale_ggsurvfit() +
  coord_cartesian(ylim = c(0.5, 1))

knitr::knit_print(FigureSurvHA)

```

```{r}
#| label: tbl-surv-Ha
#| tbl-cap: "Summary of Hip Arthritis Procedure Survival"

TableSurvHA <- tbl_survfit(
  survfit2(Surv(Duration, Status) ~ SurgicalTreatment2, 
           data = SnapshotHA),
  times = c(1,26,52,104),
  label_header = "**{time} Weeks**",
  label = "Procedure Survival",
  statistic = "{estimate} ({conf.low} - {conf.high})"
)

knitr::knit_print(TableSurvHA)

```

Although the survival of Hip Arthritis cases follows a similar trend to the Knee Arthritis cohort with a suspicion that surgical revisions are not fully captured by the registry, the surgery recommended group show a greater reluctance to follow through to surgery compared to those referred to non-surgical therapies alone.

# Monitoring Module

## Context

The AORA registry contains an additional messaging module that switches on immediate after surgery for surgical cases and sends a daily sms for the first week after surgery, and days 9, 11 and 13 in the second week, for a total of 10 in the fortnight. The monitoring module retrieves responses on pain and pain control, as well as engagement with healthcare providers, and free-text descriptions of any issues the patient is facing. The module commenced operation in July 2020 and has been running in parallel with the registry to the present.

## Flow

Confirmed arthroplasty cases are transferred to a table via filters on the registry database. Bilateral cases are reduced to one entry on the monitoring module to mitigate message duplication. On schedule, a function reviews the table and sends messages to cases that need them at \~1300 each day. Responses are returned through the system and simple filters embedded in code to review each entry. The filters are;

-   A pain score above 7 (out of 10)

-   Any response other than "no issues"

-   Self-rated quality of pain control \<3 (max 5)

-   Self-rated recovery progress of \<3 (max 5)

If a response meets any of these criteria is sent to a Slack channel that is visible to the operating surgeon, who can decide to followup with the patient by phone or other means as appropriate.

## Response Patterns

Although a response to every message sent is not expected in reality, the expectation that patients will respond to every daily message is used to calculate response rates over time.

```{r}

MonitorPlan2 <- MonitorPlan |> dplyr::filter(
  #!is.na(Phone)
  `Planned Run Status` == "Complete"
)

MonitorLog2 <- MonitorLog |> dplyr::filter(
  TreatmentID %in% MonitorPlan2$`Treatment ID`
) |> group_by(
  TreatmentID
) |> arrange(TimeStamp) |> 
  mutate(
    Sequence = row_number(),
    FormIDTrue = str_sub(MMLink, 132),
    DateStamp = lubridate::as_date(TimeStamp)
    ) |> ungroup() |>
  unite(
    col = "FormID",
    c(TreatmentID,Sequence),
    sep = ".",
    na.rm = FALSE,
    remove = FALSE
  ) |> left_join(
    STROBEInput |> dplyr::select(
      TreatmentID,
      SurgicalTreatment,
      RegistryCohortName,
      TreatmentType,
      TreatmentStatus
    ),
    by = "TreatmentID"
  )

MonitorResponse2 <- MonitorResponse |> dplyr::filter(
  TreatmentID %in% MonitorLog2$TreatmentID,
  !is.na(TreatmentDate)
) |> group_by(
  TreatmentID
  ) |> arrange(Timestamp) |> 
  mutate(Sequence = row_number()) |> 
  ungroup() |>
  unite(
    col = "FormID",
    c(TreatmentID,Sequence),
    sep = ".",
    na.rm = FALSE,
    remove = FALSE
  ) |> mutate(
    FormIDTrue = str_sub(`FormID [Office Use Only]`, 4)
  ) |> group_by(
    FormIDTrue
  ) |> mutate(
    ResponseCount = n(),
    OutOfSchedule = if_else(
      (DaysAfterSurgery == 8 | DaysAfterSurgery == 10 | DaysAfterSurgery == 12 | DaysAfterSurgery >= 14),
      TRUE,
      FALSE
    ),
    DateStamp = lubridate::as_date(Timestamp)
  ) |> ungroup() |> arrange(FormIDTrue) 

MonitorResponse3 <- MonitorResponse2 |> filter(
      DaysAfterSurgery < 14,
      OutOfSchedule == FALSE
    ) |> group_by(
      FormIDTrue
      ) |> slice_min(
      Sequence
    ) |> ungroup() |> left_join(
    STROBEInput |> dplyr::select(
      TreatmentID,
      SurgicalTreatment,
      RegistryCohortName,
      TreatmentType,
      TreatmentStatus
    ),
    by = "TreatmentID"
  )


MonitorOOS <- MonitorResponse2 |> dplyr::filter(
  OutOfSchedule == TRUE
) |> group_by(
  TreatmentID
) |> arrange(
  DaysAfterSurgery
)


```

```{r}

# More robust function to create all cumulative count data at once
create_all_cumulative_data <- function(out_data, in_data) {
  
  # Create a complete date sequence
  all_dates <- seq(min(c(out_data$DateStamp, in_data$DateStamp), na.rm = TRUE),
                   max(c(out_data$DateStamp, in_data$DateStamp), na.rm = TRUE),
                   by = "day")
  
  # Count messages out by date and cohort - separate summarise for each cohort
  CountOut_Total <- out_data |> 
    dplyr::summarise(Count_Total = n(), .by = DateStamp) |>
    arrange(DateStamp)
  
  CountOut_Knee <- out_data |> 
    filter(RegistryCohortName == "KneeArthritis") |>
    dplyr::summarise(Count_Knee = n(), .by = DateStamp) |>
    arrange(DateStamp)
  
  CountOut_Hip <- out_data |> 
    filter(RegistryCohortName == "HipArthritis") |>
    dplyr::summarise(Count_Hip = n(), .by = DateStamp) |>
    arrange(DateStamp)
  
  # Count responses in by date and cohort - separate summarise for each cohort
  CountIn_Total <- in_data |> 
    dplyr::summarise(Count_Total = n(), .by = DateStamp) |>
    arrange(DateStamp)
  
  CountIn_Knee <- in_data |> 
    filter(RegistryCohortName == "KneeArthritis") |>
    dplyr::summarise(Count_Knee = n(), .by = DateStamp) |>
    arrange(DateStamp)
  
  CountIn_Hip <- in_data |> 
    filter(RegistryCohortName == "HipArthritis") |>
    dplyr::summarise(Count_Hip = n(), .by = DateStamp) |>
    arrange(DateStamp)
  
  # Create a base dataframe with all dates
  base_dates <- tibble(DateStamp = all_dates, DateStampNum = as.numeric(all_dates))
  
  # Join all counts to the base dates
  CountOut_Combined <- base_dates |>
    left_join(CountOut_Total, by = "DateStamp") |>
    left_join(CountOut_Knee, by = "DateStamp") |>
    left_join(CountOut_Hip, by = "DateStamp") |>
    mutate(
      Count_Total = replace_na(Count_Total, 0),
      Count_Knee = replace_na(Count_Knee, 0),
      Count_Hip = replace_na(Count_Hip, 0),
      CumulativeOut_Total = cumsum(Count_Total),
      CumulativeOut_Knee = cumsum(Count_Knee),
      CumulativeOut_Hip = cumsum(Count_Hip)
    )
  
  CountIn_Combined <- base_dates |>
    left_join(CountIn_Total, by = "DateStamp") |>
    left_join(CountIn_Knee, by = "DateStamp") |>
    left_join(CountIn_Hip, by = "DateStamp") |>
    mutate(
      Count_Total = replace_na(Count_Total, 0),
      Count_Knee = replace_na(Count_Knee, 0),
      Count_Hip = replace_na(Count_Hip, 0),
      CumulativeIn_Total = cumsum(Count_Total),
      CumulativeIn_Knee = cumsum(Count_Knee),
      CumulativeIn_Hip = cumsum(Count_Hip)
    )
  
  # Combine the data
  CountAll <- CountOut_Combined |>
    select(DateStamp, DateStampNum, starts_with("CumulativeOut")) |>
    left_join(
      CountIn_Combined |> select(DateStampNum, starts_with("CumulativeIn")),
      by = "DateStampNum"
    ) |>
    # Filter to only dates where we have actual data (not empty days)
    filter(DateStamp %in% c(out_data$DateStamp, in_data$DateStamp))
  
  return(CountAll)
}

# Optional: If you want to create individual plots for specific cohorts
create_individual_plot <- function(long_data, cohort_name) {
  filtered_data <- long_data |> filter(Cohort == cohort_name)
  
  ggplot(filtered_data, aes(x = DateStamp, y = CumulativeCount, color = Type)) +
    geom_line(linewidth = 1) +
    geom_point(size = 1.5, alpha = 0.7) +
    geom_smooth(
      method = "gam", 
      formula = y ~ s(x, bs = "cs"), 
      linewidth = 1.2, 
      se = TRUE, 
      alpha = 0.2
    ) +
    scale_color_manual(
      values = c("Out" = "#e74c3c", "In" = "#3498db"),
      labels = c("Out" = "Messages Out", "In" = "Responses In")
    ) +
    labs(
      title = paste("Cumulative Message Counts Over Time -", cohort_name),
      x = "Date",
      y = "Cumulative Count",
      color = "Type"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", size = 14),
      axis.title = element_text(face = "bold"),
      panel.grid.minor = element_blank(),
      legend.position = "bottom",
      legend.title = element_text(face = "bold")
    )
}

# Example usage for individual plots if needed:
# Monitor_Individual_Total <- create_individual_plot(MonitorCountAll_Long, "All Cohorts")
# Monitor_Individual_Knee <- create_individual_plot(MonitorCountAll_Long, "Knee Arthritis")
# Monitor_Individual_Hip <- create_individual_plot(MonitorCountAll_Long, "Hip Arthritis")



```

```{r}

# Create all cumulative data at once (much more efficient!)
CombinedCumulativeData <- create_all_cumulative_data(MonitorLog2, MonitorResponse3)

```

```{r}

# Create a single long dataframe with all cohorts
MonitorCountAll_Long <- CombinedCumulativeData |>
  # Pivot to long format for all cohorts at once
  pivot_longer(
    cols = starts_with("Cumulative"),
    names_to = c("Type", "Cohort"),
    names_pattern = "Cumulative(Out|In)_(Total|Knee|Hip)",
    values_to = "CumulativeCount"
  ) |>
  mutate(
    Type = factor(Type, levels = c("Out", "In")),
    Cohort = case_when(
      Cohort == "Total" ~ "All Cohorts",
      Cohort == "Knee" ~ "Knee Arthritis", 
      Cohort == "Hip" ~ "Hip Arthritis"
    ),
    Cohort = factor(Cohort, levels = c("All Cohorts", "Knee Arthritis", "Hip Arthritis"))
  )

```

```{r}
#| label: fig-msgcount
#| fig-cap: "Cumulative Message Counts Over Time by Cohort"

# Create a single faceted plot
Monitor_Cumulative_Faceted <- ggplot(MonitorCountAll_Long, 
                                     aes(x = DateStamp, y = CumulativeCount, color = Type)) +
  geom_line(linewidth = 1) +
  geom_point(size = 1.5, alpha = 0.7) +
  geom_smooth(
    method = "gam", 
    formula = y ~ s(x, bs = "cs"), 
    linewidth = 1.2, 
    se = TRUE, 
    alpha = 0.2
  ) +
  scale_color_manual(
    values = c("Out" = "#e74c3c", "In" = "#3498db"),
    labels = c("Out" = "Messages Out", "In" = "Responses In")
  ) +
  labs(
    x = "Date",
    y = "Cumulative Count",
    color = "Message Type"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title = element_text(face = "bold"),
    panel.grid.minor = element_blank(),
    legend.position = "bottom",
    legend.title = element_text(face = "bold"),
    strip.text = element_text(face = "bold")
  ) +
  facet_wrap(~Cohort, scales = "free_y")

# Print the plot
knitr::knit_print(Monitor_Cumulative_Faceted)
```

@fig-msgcount shows the cumulative total messages sent by the system from inception, and the cumulative volume of responses received via the links provided in the sms. I have not removed multiple responses from a patient to the same link.

```{r}
# More robust function to create all cumulative count data at once
create_all_cumulative_data <- function(out_data, in_data) {
  
  # Create a complete date sequence
  all_dates <- seq(min(c(out_data$DateStamp, in_data$DateStamp), na.rm = TRUE),
                   max(c(out_data$DateStamp, in_data$DateStamp), na.rm = TRUE),
                   by = "day")
  
  # Count messages out by date and cohort - separate summarise for each cohort
  CountOut_Total <- out_data |> 
    dplyr::summarise(Count_Total = n(), .by = DateStamp) |>
    arrange(DateStamp)
  
  CountOut_Knee <- out_data |> 
    filter(RegistryCohortName == "KneeArthritis") |>
    dplyr::summarise(Count_Knee = n(), .by = DateStamp) |>
    arrange(DateStamp)
  
  CountOut_Hip <- out_data |> 
    filter(RegistryCohortName == "HipArthritis") |>
    dplyr::summarise(Count_Hip = n(), .by = DateStamp) |>
    arrange(DateStamp)
  
  # Count responses in by date and cohort - separate summarise for each cohort
  CountIn_Total <- in_data |> 
    dplyr::summarise(Count_Total = n(), .by = DateStamp) |>
    arrange(DateStamp)
  
  CountIn_Knee <- in_data |> 
    filter(RegistryCohortName == "KneeArthritis") |>
    dplyr::summarise(Count_Knee = n(), .by = DateStamp) |>
    arrange(DateStamp)
  
  CountIn_Hip <- in_data |> 
    filter(RegistryCohortName == "HipArthritis") |>
    dplyr::summarise(Count_Hip = n(), .by = DateStamp) |>
    arrange(DateStamp)
  
  # Create a base dataframe with all dates
  base_dates <- tibble(DateStamp = all_dates, DateStampNum = as.numeric(all_dates))
  
  # Join all counts to the base dates
  CountOut_Combined <- base_dates |>
    left_join(CountOut_Total, by = "DateStamp") |>
    left_join(CountOut_Knee, by = "DateStamp") |>
    left_join(CountOut_Hip, by = "DateStamp") |>
    mutate(
      Count_Total = replace_na(Count_Total, 0),
      Count_Knee = replace_na(Count_Knee, 0),
      Count_Hip = replace_na(Count_Hip, 0),
      CumulativeOut_Total = cumsum(Count_Total),
      CumulativeOut_Knee = cumsum(Count_Knee),
      CumulativeOut_Hip = cumsum(Count_Hip)
    )
  
  CountIn_Combined <- base_dates |>
    left_join(CountIn_Total, by = "DateStamp") |>
    left_join(CountIn_Knee, by = "DateStamp") |>
    left_join(CountIn_Hip, by = "DateStamp") |>
    mutate(
      Count_Total = replace_na(Count_Total, 0),
      Count_Knee = replace_na(Count_Knee, 0),
      Count_Hip = replace_na(Count_Hip, 0),
      CumulativeIn_Total = cumsum(Count_Total),
      CumulativeIn_Knee = cumsum(Count_Knee),
      CumulativeIn_Hip = cumsum(Count_Hip)
    )
  
  # Combine the data
  CountAll <- CountOut_Combined |>
    select(DateStamp, DateStampNum, starts_with("CumulativeOut")) |>
    left_join(
      CountIn_Combined |> select(DateStampNum, starts_with("CumulativeIn")),
      by = "DateStampNum"
    ) |>
    # Filter to only dates where we have actual data (not empty days)
    filter(DateStamp %in% c(out_data$DateStamp, in_data$DateStamp))
  
  return(CountAll)
}

```

```{r}

# Function to calculate response rates from combined data
calculate_response_rates <- function(combined_data, rate_type = "daily") {
  
  if (rate_type == "daily") {
    # Calculate daily response rates
    response_rates <- combined_data |>
      mutate(
        # Calculate daily response rates (avoiding division by zero)
        ResponseRate_Total = ifelse(CumulativeOut_Total > 0, 
                                   CumulativeIn_Total / CumulativeOut_Total * 100, 0),
        ResponseRate_Knee = ifelse(CumulativeOut_Knee > 0, 
                                  CumulativeIn_Knee / CumulativeOut_Knee * 100, 0),
        ResponseRate_Hip = ifelse(CumulativeOut_Hip > 0, 
                                 CumulativeIn_Hip / CumulativeOut_Hip * 100, 0)
      ) |>
      select(DateStamp, DateStampNum, starts_with("ResponseRate")) |>
      # Convert to long format
      pivot_longer(
        cols = starts_with("ResponseRate"),
        names_to = "Cohort",
        names_pattern = "ResponseRate_(.*)",
        values_to = "ResponseRate"
      ) |>
      mutate(
        Cohort = case_when(
          Cohort == "Total" ~ "All Cohorts",
          Cohort == "Knee" ~ "Knee Arthritis",
          Cohort == "Hip" ~ "Hip Arthritis"
        ),
        Cohort = factor(Cohort, levels = c("All Cohorts", "Knee Arthritis", "Hip Arthritis"))
      )
    
  } else if (rate_type == "weekly") {
    # Calculate weekly response rates
    response_rates <- combined_data |>
      mutate(
        Week = floor_date(DateStamp, "week"),
        # Calculate weekly response rates
        ResponseRate_Total = ifelse(CumulativeOut_Total > 0, 
                                   CumulativeIn_Total / CumulativeOut_Total * 100, 0),
        ResponseRate_Knee = ifelse(CumulativeOut_Knee > 0, 
                                  CumulativeIn_Knee / CumulativeOut_Knee * 100, 0),
        ResponseRate_Hip = ifelse(CumulativeOut_Hip > 0, 
                                 CumulativeIn_Hip / CumulativeOut_Hip * 100, 0)
      ) |>
      # Take the last observation for each week (most recent cumulative rate)
      group_by(Week) |>
      slice_max(DateStamp, n = 1) |>
      ungroup() |>
      select(Week, starts_with("ResponseRate")) |>  # Remove DateStamp from select
      # Convert to long format
      pivot_longer(
        cols = starts_with("ResponseRate"),
        names_to = "Cohort",
        names_pattern = "ResponseRate_(.*)",
        values_to = "ResponseRate"
      ) |>
      mutate(
        Cohort = case_when(
          Cohort == "Total" ~ "All Cohorts",
          Cohort == "Knee" ~ "Knee Arthritis",
          Cohort == "Hip" ~ "Hip Arthritis"
        ),
        Cohort = factor(Cohort, levels = c("All Cohorts", "Knee Arthritis", "Hip Arthritis"))
      ) |>
      rename(DateStamp = Week)  # Now this won't cause a duplicate
  }
  
  return(response_rates)
}


```

```{r}

# Function to create response rate plot
create_response_rate_plot <- function(response_data, rate_type = "daily") {
  
  time_label <- ifelse(rate_type == "daily", "Daily", "Weekly")
  
ggplot(response_data, aes(x = DateStamp, y = ResponseRate, color = Cohort)) +
    geom_line(linewidth = 1) +
    geom_point(size = 1.5, alpha = 0.7) +
    # Add smooth trend line
    geom_smooth(
      method = "loess", 
      span = 0.3,
      linewidth = 1.2, 
      se = TRUE, 
      alpha = 0.2
    ) +
    # Custom colors for cohorts
    scale_color_manual(
      values = c(
        "All Cohorts" = "#2c3e50",
        "Knee Arthritis" = "#e74c3c", 
        "Hip Arthritis" = "#3498db"
      )
    ) +
    # Format y-axis as percentage
    scale_y_continuous(
      labels = scales::percent_format(scale = 1),
      limits = c(0, NA)
    ) +
    # Labels and title
    labs(
      title = paste(time_label, "Response Rate Over Time by Cohort"),
      x = "Date",
      y = "Response Rate (%)",
      color = "Cohort"
    ) +
    # Theme
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", size = 14),
      axis.title = element_text(face = "bold"),
      panel.grid.minor = element_blank(),
      legend.position = "bottom",
      legend.title = element_text(face = "bold"),
      strip.text = element_text(face = "bold")
    ) +
    facet_wrap(~Cohort, scales = "free_y")
}

```

```{r}
#| label: fig-responsedaily
#| fig-cap: "Daily response rate separated by cohorts over time"


# Daily response rates
ResponseRates_Daily <- calculate_response_rates(CombinedCumulativeData, "daily")
ResponseRate_Daily_Plot <- create_response_rate_plot(ResponseRates_Daily, "daily")

knitr::knit_print(ResponseRate_Daily_Plot)

```

```{r}
#| label: fig-responseweekly
#| fig-cap: "Weekly response rate separated by cohorts over time"


# Weekly response rates  
ResponseRates_Weekly <- calculate_response_rates(CombinedCumulativeData, "weekly")
ResponseRate_Weekly_Plot <- create_response_rate_plot(ResponseRates_Weekly, "weekly")

knitr::knit_print(ResponseRate_Weekly_Plot)

```

The response rates for both cohorts have recently stabilised at \~50%, the hip cohort improving over time, in contrast to the knee cohort for both daily @fig-responsedaily and weekly @fig-responseweekly rates.

### Alerts

The rate at which patient responses were presented to the surgeon through the internal messaging platform was also calculated.

```{r}
MonitorResponse4 <- MonitorResponse3 |> rename(
  Q1 = "Do you have an issue that is concerning you about your recovery?",
  Q1b = "Please describe the issue/s",
  Q1c = "Have you seen or are you thinking about seeing a health provider provider for this issue?",
  Q2 = "How would you rate your recovery in the last 24 hours?",
  Q3 = "How would you rate how well your pain has been controlled over the last 24 hours?",
  Q4 = "How would you rate your WORST episode of pain over the last 24 hours?",
  Q5 = "What pain killers have you taken in the last 24 hrs? [Panadol/Panadol Osteo]",
  Q6 = "What pain killers have you taken in the last 24 hrs? [Non-steroidal anti-inflammatory]",
  Q7 = "What pain killers have you taken in the last 24 hrs? [Other, stronger pain killers]",
  Q8 = "What extra pain killers have you taken in the last 24 hrs?",
  Q9 = "How far do you think you have walked in the last 24 hours? (metres)"
) |> dplyr::mutate(
  Alert1 = case_when(
    stringr::str_detect(Q1, "No issues", negate = TRUE) | Q3 < 3 | Q4 > 7 | !is.na(Q1b) ~ "Alert",
    .default = "Storage"
    
  )
)
```

```{r}
# Create weekly alert rate data for total and by registry cohort
weekly_alert_rate_total <- MonitorResponse4 %>%
  mutate(Week = floor_date(DateStamp, "week")) %>%
  group_by(Week) %>%
  summarise(
    Total_Responses = n(),
    Alert_Responses = sum(Alert1 == "Alert", na.rm = TRUE),
    Alert_Rate = Alert_Responses / Total_Responses,
    RegistryCohortName = "All Cohorts",
    .groups = "drop"
  ) %>%
  filter(Total_Responses >= 5)

weekly_alert_rate_by_cohort <- MonitorResponse4 %>%
  mutate(Week = floor_date(DateStamp, "week")) %>%
  group_by(Week, RegistryCohortName) %>%
  summarise(
    Total_Responses = n(),
    Alert_Responses = sum(Alert1 == "Alert", na.rm = TRUE),
    Alert_Rate = Alert_Responses / Total_Responses,
    .groups = "drop"
  ) %>%
  filter(Total_Responses >= 3)  # Lower threshold for individual cohorts

# Combine data for plotting
weekly_alert_rate_combined <- bind_rows(
  weekly_alert_rate_total,
  weekly_alert_rate_by_cohort
) %>%
  mutate(RegistryCohortName = factor(RegistryCohortName, 
                                   levels = c("All Cohorts", 
                                            sort(unique(MonitorResponse4$RegistryCohortName)))))

```

```{r}
#| label: fig-alert
#| fig-cap: "Alert Response Rate by Week - Total and by Registry Cohort: Proportion of responses flagged as 'Alert' per week with trend lines"

# Create the plot with facets
p1 <- ggplot(weekly_alert_rate_combined |> dplyr::filter(!is.na(RegistryCohortName)), aes(x = Week, y = Alert_Rate)) +
  geom_line(aes(color = RegistryCohortName), alpha = 0.6, size = 0.8) +
  geom_point(aes(color = RegistryCohortName), alpha = 0.7, size = 1) +
  geom_smooth(aes(color = RegistryCohortName), method = "gam", 
              formula = y ~ s(x, bs = "cs"), size = 1.2, se = FALSE) +
  facet_wrap(~ RegistryCohortName, scales = "free_y", ncol = 2) +
  scale_y_continuous(
    labels = scales::percent_format(accuracy = 1)
  ) +
  scale_x_date(
    date_labels = "%b %Y",
    date_breaks = "6 months"
  ) +
  scale_color_viridis_d(name = "Registry Cohort") +
  labs(
    x = "Month",
    y = "Alert Rate (%)",
    caption = paste("Total responses:", nrow(MonitorResponse4))
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12, color = "gray60"),
    legend.position = "none",  # Remove legend since facets show the groups
    strip.text = element_text(face = "bold", size = 10),
    panel.grid.minor.x = element_line(color = "gray95", size = 0.3)
  )

knitr::knit_print(p1)
```

The fitted trend lines in @fig-alert show a significant overall reduction in alert rates over time. Considering that the response rate has remained recently stable over time, this may suggest improved care during acute recovery or longer hospital length of stay.

# Interpretation

-   The registry is coming towards end of life with respect to HREC approval

-   PROMs capture ranges from \~ 70% (preoperative) to 50% for surgical cases at most postoperative timepoints.

-   Patients undergoing surgery present with reasonably high expectations of symptom relief and this is largely met as reflected in satisfaction postoperatively

-   AORA contains a subgroup within each cohort that have been offered surgery, but tend to take it up at the same rate as patients that have been treated nonoperatively initially

-   Surgical and non-surgical cases display starkly different patterns of recovery in joint-specific PROMs over time

-   More than half of Knee Arthritis surgical cases report moderate to no difficulty with kneeling at 6 weeks

-   Complications that represent to the clinic have been detected, but surgical failures may be under reported in this registry

-   The monitoring module maintains a steady response rate, although these differ between cohorts, but demonstrates potential improvements in acute care over time

# Recommendations

-   Review initial registry results and consider investment in key papers on outcomes of interest

    -   Consider a comparison of clinical outcomes to historical controls previously published

-   Review intended use of registry data and consider

    -   EBMA offering

    -   Continuing AORA with modifications
